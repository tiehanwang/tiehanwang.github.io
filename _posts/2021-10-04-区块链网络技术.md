---
layout: 	post
title: 		区块链网络技术
subtitle:	区块链
date:		2021-10-04
author: 	W
header-img: img/post-bg-bit.png
catalog: true
tags: 
    - 区块链
    - P2P
---



# 区块链网络技术

## P2P网络简介

P2P网络中的P2P指的是Peer-To-Peer，既点对点网络，网络的参与者共享他们所拥有的一部分硬件资源（处理能力、存储能力、网络连接能力、打印机等），这些共享资源通过网络提供服务和内容，能被其它对等节点(Peer)直接访问而无需经过中间实体。在此网络中的参与者既是资源（服务和内容）提供者（Server），又是资源获取者（Client）。

P2P网络的定义如下：

- 有某网络N，是架构在Internet之上的网络，满足Internet网络的所有基本特征。

- 在N网络中，存在两种基本的行为模式，一种行为定义为P，是生产资源（提供资源）的行为，另一种行为定义C，是消费资源（接受资源）的行为。

- 组成N网络的所有网络节点( Peer)之间是对等的关系，且同时具备行为P和行为C。

- 在N网络中，各Peer之间以无中介的、对等的方式进行双向交换，以执行P和C 的功能。

- N网络依赖于Peer的存在而存在，且Peer可以自由地加入或退出。

- 当有Peer加入或退出时，N网络仍保持组织、结构等特性不发生改变。

满足以上6个条件的网络N，就可以说是P2P网络。

P2P技术的特点在应用中体现了下面的一些优势：

- **非中心化**
- **可扩展性**
- **健壮性**
- **高性价比**
- **隐私保护**
- **负载均衡**

## P2P网络的类型

根据拓扑结构的关系可以将P2P网络拓扑结构分为4种形式：

- 集中式拓扑（Centralized Topology，也称作中心化拓扑）。

- 全分布式结构化拓扑（Decentralized Structured Topology，也称作DHT网络）。

- 全分布式非结构化拓扑（Decentralized Unstructured Topology）。

- 混合式拓扑（Partially Decentralized Topology，也称作部分中心化拓扑）。 

以上这4种P2P的网络结构，分别于P2P发展的不同时期出现，因而在其分类过程中，也可以按P2P发展的“代”来划分。集中式P2P网络常对应于第一代P2P，而第二代P2P则是全分散分布式网络体系结构，也叫纯P2P网络结构，第三代P2P，就是混合式的P2P网络结构。

### 集中式的P2P网络

***

集中式P2P网络，类似于一个抽象的“星形网络拓扑”，由一个中央服务以星状的形式与各客户机连接，但这种连接并不是物理上的星状拓扑，而是基于集中式P2P网络拓扑协议而形成的一个虚拟的星状结构。

在集中式P2P网络中，网络的主体由一个处于中心地位的索引目录服务器和连接到目录服务器的各节点客户机组成，目录服务器用来管理和组织P2P的各客户端节点。

在网络运行过程中，P2P节点向中央目录服务器注册关于自身的信息（名称、地址、资源和元数据等），但这些注册的所有内容都分散式地存储在各个节点中而非并服务器上，查询节点根据目录服务器中的信息以及网络流量和延迟等信息，来选择与定位其他对等点并直接建立连接，而不必经过中央目录服务器进行。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-centralized.PNG)

在集中式的P2P网络结构中，由目录服务器管理和组织节点信息，各个对等的客户端，也就是Peer节点要加入到P2P系统中的时候，都要登录到中心目录服务器（也叫索引服务器或中心服务器）上，如图2-6中的Directory Server。

在这种集中式的P2P网络中，中央服务器用来保存所有Peer节点用户上传的文件索引和存放位置的信息，以及拥有此文件节点自身的信息，当某个用户需要某个文件时，首先连接到中央服务器，再对服务器进行检索，并由服务器返回存有该文件的用户信息：再由请求者直接连到文件所有者所在的节点主机上，与此主机建立连接以传输文件。

#### 集中式P2P网络的优缺点

**集中式P2P网络最大的优点**是维护简单，有效提高了网络的可管理性。同时，在资源的搜索与发现方面，由于资源的发现依赖中心化的目录系统，发现算法灵活、高效并能够实现复杂查询，使得对共享资源的查找和更新非常方便，资源发现效率高，这是集中式P2P的优点。

集中式P2P也存在一些问题，最大的问题与传统客户机／服务器结构类似，容易造成单点故障。总结起来，这种P2P网络结构易出现的问题主要表现在以下几个方面。

- 中央服务器的瘫痪容易导致整个网络的崩溃，可靠性和安全性较低。如果该服务器失效，整个系统都会瘫痪。

- 随着网络规模的扩大，当用户数量大量增加时，系统的性能会大大下降。对中央索引服务器进行维护和更新的费用将急剧增加，所需成本过高。

- 中央服务器的存在，容易引起共享资源在版权问题上的纠纷。

总之，从P2P的实质意义上讲，集中式P2P网络非纯粹意义上的P2P网络模型。对小型网络而言，集中目录式模型在管理和控制方面占一定优势。但鉴于其存在的种种缺陷，该模型并不适合大型的P2P网络应用。

在P2P的发展历程中，第一代P2P网络普遍采用的就是这种集中式结构模式，无论集中式的P2P存在多少问题，它曾经引领了一代P2P技术的发展，至今也仍有应用，最经典的案例就是著名的MP3共享软件Napster。

### 全分布式结构化P2P网络

***

全分布式结构化拓扑的P2P网络采用了分布式哈希表技术(（Distributed Hash Table，DHT）)来组织网络中的节点，全分布式P2P网络的实现方式也正是DHT技术的完美应用。

基于DHT的网络采用了较为结构化的基于键值对（K，V）的路由方法:

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Structured.PNG)

#### 优点

在P2P网络中，DHT类结构能够自适应节点的动态加入／退出，有着良好的可扩展性、鲁棒性、节点ID分配的均匀性和自组织能力。

由于重叠网络采用了确定性拓扑结构，DHT可以提供精确的发现。只要目的节点存在于网络中，DHT总能发现它，发现的准确性也会得到保证。

#### 缺点

基于DHT的全分布式结构化P2P系统最大的**问题**是DHT的维护机制较为复杂，尤其是节点频繁加入和退出所造成的网络波动会极大增加DHT的维护代价，这是全分布式结构化的P2P拓扑存在的主要问题。

DHT所面临的另外一个**问题**是DHT仅支持精确关键词匹配查询，无法支持内容／语义等复杂查询。在网络技术快速发展的今天，智能搜索、语义查询等技术成为必然的趋势，P2P网络及其搜索技术在这方面必须要有所突破。

### 全分布式非结构化P2P网络

***

 全分布式非结构化的P2P网络系统构建比较简单随意，在实际应用中适合于信息发布、即时通信等主机随时加入和退出的情况。

采用这种拓扑结构最典型的案例便是Gnutella（纽特拉）。Gnutella（纽特拉）网络见下图

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-UnStructured.PNG)

#### 优点

采用非结构化的P2P系统，对网络的动态变化有较好的容错能力，具有较好的可用性。同时可以支持复杂查询，如带有规则表达式的多关键词查询、模糊查询等

#### 缺点

在非结构化的P2P网络中，随着联网节点的不断增多，网络规模不断扩大，通常采用泛洪（Flooding）方式定位对等点，往往造成网络流量急剧增加，从而导致网络中部分低带宽节点因网络资源过载而失效。

由于没有确定拓扑结构的支持，分布式的P2P网络无法保证资源发现的效率，因此发现的准确性和可扩展性是非结构化网络面临的两个重要问题。目前对此类结构的研究主要集中于改进发现算法和复制策略以提高发现的准确率和性能。



全分布式P2P网络结构，包括结构化和非结构化的，它们都较好地解决了网络结构中心化的问题，扩展性和容错性较好，通常也称为第二代P2P结构，是对第一代集中式P2P网络结构的优化和完善，在P2P的研究和发展过程中，有重要的地位。

### 混合式P2P网络 

***

在混合式P2P网络结构中，将整个网络中的节点按能力不同（计算能力、内存大小、连接带宽、网络滞留时间等）区分为普通节点和超级节点两类。超级节点也叫搜索节点，它与其临近的若干普通节点之间构成一个小型的、自治的、基于集中式的P2P网络模式，如图所示为混合式P2P网络结构模型。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Mix.PNG)

在图2.2.5所示的结构模型中，处于中间位置的4台大主机定义为超级节点，类似于一个小型集中式P2P网络的目录服务器。整个P2P网络中再通过分布式的P2P网络模式将超级节点相连起来，就组成了一个混合式的网络结构。

​     混合式P2P网络拓扑中包含两类节点，一类是搜索节点，另一类是普通节点。**搜索节点与其临近的若干普通节点之间构成一个自治的“簇”**，在每一个“簇”内采用基于集中目录式的P2P模式。整个P2P网络中各个不同的“簇”之间再通过纯P2P的模式将搜索节点相连起来，这样就组成了一个混合式的拓扑。 
​     这种混合式的P2P拓扑结构在工作过程中，**一般会选择一些性能较好的节点作为超级节点，也就是索引节点**。当有节点加入或退出时，系统可以在各个搜索节点之间再次选取性能最优的节点，或者另外引入一新的性能最优的节点作为索引节点来保存整个网络中可以利用的搜索节点信息，并且负责维护整个网络的结构。

#### 优点

在混合式的P2P网络拓扑中，由于在各个超级点上存储了系统中其他部分节点的信息，发现算法仅在超级点之间转发。如果查询结果不充分，超级点再将查询请求转发给适当的叶子节点进行有限的泛洪。这样就极为有效地消除了纯的分布式P2P结构中使用泛洪算法带来的网络拥塞、搜索迟缓等不利影响。

另一方面，每个簇中的搜索节点负责监控所有普通节点的行为，能确保一些恶意的攻击行为在网络中得到局部控制，在一定程度上提高整个网络的负载平衡。

在混合P2P网络结构中，当网络规模扩大时，就可以在各个超级节点之间再次选取性能最优的节点，或者另外引入一新的性能最优的节点作为超级节点，这样超级节点能随着网络规模扩大而自适应的增加。

#### 缺点

因为其对超级点依赖性大，易于受到集中攻击，容错性也受到影响。

混合式P2P网络结合了集中式拓扑的易管理性与分布式拓扑的可扩展性，在异构的P2P网络环境下是一种较好的模式选择。其中最典型的案例就是KaZaa。

### P2P网络的对比

***

| **比较标准／拓扑结构** | **集中式** | **全分布式非结构化** | **全分布式结构化** | **混合式** |
| ---------------------- | ---------- | -------------------- | ------------------ | ---------- |
| **可扩展性**           | 差         | 差                   | 好                 | 中         |
| **可靠性**             | 差         | 好                   | 好                 | 中         |
| **可维护性**           | 最好       | 最好                 | 好                 | 中         |
| **发现算法的效率**     | 最高       | 中                   | 高                 | 中         |
| **复杂查询**           | 支持       | 支持                 | 不支持             | 支持       |

## 结构化P2P网络的搜索技术

在结构化P2P网络中，整个网络具有相对稳定而规则的拓扑结构。网络的每个节点都有一个逻辑地址，并把逻辑地址和节点的IP地址对应起来，然后将数据（或引用数据）分发到一组节点上，每一个对等节点负责一系列数据项。

在实际的系统中，P2P网络的逻辑地址通常是由Hash函数得到的，**每个节点都将保存一张DHT（Distributed Hash Table）进行路由，所以结构化P2P网络通常也叫作DHT网络。**

### **分布式哈希表**

***

一个分布式哈希表（Distributed Hash Table，DHT）根据预先定义的规则将每个数据项和对等节点都被映射到大小为2^m的地址上。然后将数据（或引用数据）分发到一组节点上。每一个对等节点负责一系列数据项。

基于DHT的网络要求每个对等节点对整个网络做部分了解。这些对网络的了解可用于把对某数据项的查询路由到负责该资源的节点上。

#### **地址空间**

在基于DHT的网络中，地址空间使用模运算进行设计，这意味着我们可以把地址空间的节点想象为圆环上顺时针均匀分布的2^m个点（编号为0到2^m -1），如图2.2.6所示，绝大多数的DHT使用m = 160。

#### **对等节点标识符**

创建DHT系统的第一步是将所有对等节点放入地址空间环中。这通常使用哈希函数来完成，哈希函数将对等节点标识符进行映射，通常是它的IP地址，生成一个称为节点ID的m位整数。

节点 ID = hash (对等节点IP地址)

哈希函数是一个数学函数，通常DHT使用了某些加密哈希函数，例如安全哈希算法（Secure Hash Algorithm，SHA），这些函数是冲突避免的。这意味着两个输入被映射到同一个输出的概率是很低的。

#### **对象标识符**

被共享的对象的名称（例如一个文件）也被哈希成相同地址空间上的一个m位整数。哈希结果在DHT术语中称为关键字（key）。

关键字 = hash (对象名)

在DHT中，一个对象通常和一组（key，value）相关，其中key是对象名的哈希值，value是对象或对象的引用。

#### **存储对象**

存储对象有两种策略：直接方法和间接方法。

在直接方法中，环中的哪个节点ID与对象的关键字最接近（closest），就将对象存储在那个节点上。最接近（closest）这个术语在每个协议中定义不同。这涉及了最可能传输这个对象的电脑，这个电脑最初拥有这个对象。

然而由于效率缘故，绝大多数DHT系统使用间接方法。拥有对象的对等节点保存对象，但是对象的引用被创建并存储在另一个节点上，这个节点的ID最接近关键字。换言之，**物理对象以及对其引用被存储在两个不同的地点**。在直接策略中，我们创建了存储对象的那个节点的ID与对象关键字之间的关系；在间接策略中，我们创建了对象引用（指针）与存储引用的那个节点之间的关系。在这两种情况中，如果给出对象名字就需要利用这个关系才能找到对象。一般情况下使用间接方法。

间接方法常见查找为：先求所找key的hash映射到环上一点后，顺时针找到最近的物理节点，再通过物理节点中的引用值(通常为ip及端口)找到实际存储的节点，访问实际节点即可找到真正值。

#### **路由**

DHT的主要功能是将一个查询请求路由到负责存储这个对象引用的节点上。每个DHT的具体实现都使用不同的策略来路由，DHT网络的每个节点必须对整个环有部分了解，从而将查询请求路由到负责节点上。

#### **节点的加入和离开**

在P2P网络中，每个对等节点可以是一个台式机或一台笔记本电脑，对等节点可以开机或关机。当一个计算机对等节点安装并运行了DHT软件，它就加入了这个P2P网络；当计算机关机或者对等节点关闭了软件，它就离开网络。一种DHT的实现需要一种清晰、有效的策略来处理节点的加入和离开，并处理对其余节点的影响。**绝大多数DHT实现将节点失效看做节点离开**。

#### **分布式哈希表的特性**

- 离散性:构成系统的节点并没有任何中央式的协调机制。

- 伸缩性:即使有成千上万个节点，系统仍然应该十分有效率。

- 容错性:即使节点不断地加入、离开或是停止工作，系统仍然必须达到一定的可靠度。

分布式哈希表必须处理传统分布式系统可能遇到的问题，例如负载平衡、数据完整性，以及效能问题(特别是确认转送消息、数据存储及读取等动作能快速完成)。

### Chord算法

#### **标识符空间和对象存储**

- Chord环：是一个大小为2^m的环，地址空间的数学运算是模2^m进行的，标识符号码在0到2^m-1范围内。用于共享对象分配（给某一个节点）和节点分布，以及对象定位。节点顺时针由小到大放在这个环上。在Chord中使用哈希函数SHA-1来进行哈希计算，m=160。

- 节点标识符：NID（node identifier），标识一个节点，m位的一个数字，由节点的IP地址通过哈希操作得到。

- 对象标识符；KID（key identifiers），标识一个对象，Key由对象名称通过哈希操作得到。

  **我们将对象的标识符称为关键字记为k（即key），对等节点的标识符记为N（即node)**

- 后向节点：对等节点N称作对象k的后向节点，是在环上从k起顺时针方向的节点，记为successor(k)，第一个后向节点成为直接后向节点。

- 前向节点：对等节点N称作对象k的前向节点，是在环上从k起逆时针方向的节点，记为predecessor (k)，第一个前向节点成为直接前向节点。

- 对象存储：关键字为k的对象引用信息存储在k的直接后向节点中，信息以（k，v）对的形式存储，其中k是关键字（数据项的哈希值），v是数值（关于拥有对象的对等节点服务器的信息）。换言之，数据项存储在拥有数据项的对等节点上，但是数据项的哈希值key以及拥有数据项对等节点的信息value被作为一对（k，v）存储在k的直接后向节点上。这意味着存储数据项的对等节点和拥有（k，v）对的节点不必是同一个节点。

我们在讨论中令m = 5使得讨论更简单。

#### **指针表**

在Chord算法中，每个节点都要维护一个包含部分节点信息的列表，这个列表在信息搜索时用于路由，实际上是一个路由表，这个列表称为指针表（finger table）。

Chord算法的这个指针表维护m个（行）关键字的后向节点列表以及当前节点的前向节点的信息。指针表的每一行i是存储关键字（对象标识符）为N+2i-1的引用信息的节点，如表所示（表中只给出了后向节点列表的构造）。

| i    | 目标Key   | 目标Key的后向节点   | 后向节点的IP地址和端口 |
| ---- | --------- | ------------------- | ---------------------- |
| 1    | N+2^0     | N+2^0的后向节点     | 后向节点的IP地址和端口 |
| 2    | N+2^1     | N+2^1的后向节点     | 后向节点的IP地址和端口 |
| ...  |           |                     |                        |
| m    | N+2^(m-1) | N+2^(m-1)的后向节点 | 后向节点的IP地址和端口 |

举例如图：

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Chord.PNG)

为了完成Chord算法的功能，Chord需要一组操作，下面介绍一些主要的操作：

#### 查找

查找是Chord中最常用的操作。

Chord让对等节点之间共享可用服务，为了找到被共享的对象，对等节点需要知道负责那个对象的节点，即存储对象引用的对等节点。

在Chord中，关键字的直接后向节点就是负责存储关键字相关信息的节点。找到负责节点实际上就是找关键字的直接后向节点。

下面给出向节点N请求查找关键字key操作的伪代码。

```!
Lookup(key)
{
     if(node is responsible for the key)
          return(node's ID)  //如果是当前节点直接返回
     else
          return find_succesor(key) //找key的后向节点
}
find_succesor(id)
{
     x=find_predecessor(id) //找key的前向节点
     return x.finger[1] //前项节点的指针表第一行的节点就是key的后向节点
}
find_predecessor(id)
{
     x=N
     while(id not in [x, x.finger[1] ]) //如果当前id不在当前节点和指针表第一项之间
          {
              x=x.find_closest_predecessor(id) //查找最近的前向节点 更新x
          }
     return x //在当前节点和指针表第一项之间 则当前节点即为前向节点
}
x.find_closest_predecessor(id)
{
    for (i=m down to 1) //倒序 因为倒序是从大到小
    {
          if(finger[i]∈[x,id]) //如果第i行的节点在x到id之间 则将x更新为finger[i]
          	return finger[i]
    }
	return x  //（节点x是最接近的前向节点）
}
```

 

上述伪代码描述了从查询节点N开始查找关键字Key的过程，让我们来仔细研究这个操作过程：

- Lookup(key)：如果查询节点N负责关键字，它返回自己的ID；否则，它调用函数find_successor（Key），查找关键字的后向节点，该节点存储着关键字Key的引用信息；

- find_successor（Key）：调用函数find_predecessor（Key），查找关键字的前向节点，找到的这个节点的指针表中的第一项就应该是要查找的节点：

- find_predecessor（Key）：从查询节点开始循环查找，首先设置当前节点值为查询节点：

  a)    如果查询关键字不在当前节点和当前节点的指针表第一项的节点之间，则在当前节点中调用x. find_closest_predecessor(Key)，在当前节点的指针表中查找最接近查询关键字的节点；然后把找到的节点设置成当前节点，重复这个步骤。

  b)   如果关键字标识符在当前节点和当前节点的指针表第一项的节点之间，说明当前节点是查询关键字的前向节点，则返回当前节点标识符。

- x. find_closest_predecessor（Key）代表在节点x上调用find_closest_predecessor函数，查找最接近关键字的前向节点。它从节点x的指针表的最后一项开始查找：

  a)    如果该项的节点在x和关键字之间，则返回该项的标识符，这就是最接近关键字key的节点；

  b)   如果该项的节点不在节点标识符和关键字之间，则向上移动一行，重复步骤a)；

  c)    如果在x的指针表中都没有找到符合条件的节点，则返回x。

我们在算法中使用表达式x.procedure，其中x是远程节点的标识符，procedure表示被执行的程序。节点使用这个函数在x的指针表中找到一个最接近关键字前向节点的点。然后，它将寻找前向节点的责任传递给其他节点。换言之，如果节点A想要找到节点X，它找节点B（最接近前向节点）并且把任务发送给B。现在节点B接管控制并且试图寻找X，或者B将任务发送给另一个节点C。任务被从一个节点转发到另一个节点，直到一个节点为止，即那个节点拥有所要找的前向节点的信息。

#### **稳定化**

Chord网络中的任何改变（例如，节点的加入和离开）可能导致网络不稳定。Chord中定义了一个操作称为稳定化。网路中每个节点周期性地使用这个操作来验证它的后向节点，并且令后向节点验证它的前向节点信息。

节点N使用finger [1]的值S来要求节点S返回它的前向节点P。如果从这个请求中得到的返回值P在N和S之间，这意味着存在一个标识符（ID）等于P的节点，它位于N与S之间。节点N使P成为它的后向节点，N并通知P更改其前向节点。下面给出了稳定化操作的伪代码:

 

```

Stabilize()
{
	P=finger[1].Pre     //指针表的第一项节点返回它的前向节点
	if（ P∈（N, finger[1]））finger[1]=P   //P是N的后向节点
	finger[1].notify(N)	                         //N通知P改变它的前向节点
}
notify(x)
{
	if （Pre=null or x∈（Pre ,N]） Pre=x 
}//  如果前向节点为空或x比原有前向节点更接近，就将前向节点更新为x。

```

#### **指针表更新**

Chord中定义的另一个操作是fix_finger。环中的每个节点必须周期性地调用这个函数来进行指针表更新。为了减少系统的通信量，每个节点必须在每次调用中只更新它的一行指针表。这个行号是随机选择的。
Fix_Finger操作的伪代码:

```
Fix_Finger()
{
	Generite(i∈(1,m])             //随机生成i，1<i《m
	finger[i]=find_successor(N+2i-1)  //找到 finger[i]的值
}

```

#### **节点加入**

当一个对等节点加入环，它通过环中已经存在的一个节点调用使用join操作加入，Join操作的伪代码如下（N为新加入节点的标识符，x为已经存在的节点）： 

```
Join (x)
{
     Initialize(x)       
     finger[1].Move_Keys(N) 
}
Initialize(x) 
{
	Pre=null
  	if（x=null）finger[1]=N
	else finger[1]=x. find_successor(N)
}
Move_Keys(x)
{
     for(each key k)
     {
          if(x∈[k，N) move (k to node x)  //N是当前节点
     }
}
```



（1）Initialize(x)函数首先将新节点的前向节点置为空；

（2）然后把新节点的标识符作为关键字，在辅助节点中查找这个关键字的后向节点，用这个后向节点更新新节点的指针表的第一行；

（3）新节点要求后向节点调用Move_Keys函数来传输新对等节点负责的关键字信息。

在完成上述过程之后，各个节点周期性地运行Stabilize以及fix_finger操作将逐渐稳定系统。

#### 算法分析

Chord算法与其他算法相比有一定的优越性，这些优点主要体现在：

- 负载平衡：这一优点来自于一致性哈希，也就是一致性哈希中提到的平衡性。所有的节点以同等的概率分担系统负荷，从而可以避免某些节点负载过大的情况。

- 分布性：Chord是纯分布式系统，节点之间完全平等并完成同样的工作。这使得Chord具有很高的鲁棒性，可以抵御DDOS攻击攻击。

- 可扩展性：Chord协议的开销随着系统规模（节点总数N）的增加而按照O(log N)的比例增加。因此Chord可以用于大规模的系统。

- 可用性：Chord协议要求节点根据网络的变化动态地更新查询表，因此能够及时恢复路由关系，使得查询可以可靠地进行。

- 命名的灵活性：Chord并未限制查询内容的结构，因此应用层可以灵活地将内容映射到键值空间而不受协议的限制。

### Pastry算法

Pastry在2001年由位于英国剑桥的微软研究院和莱斯(Rice)大学提出，同Chord一样，它也是DHT网络的一个变种。Pastry的典型应用包括PAST和SCRIBE。

Pastry使用DHT，但是Pastry与Chord之间在标识符空间和路由过程中有一些根本性的不同。

#### **标识符空间**

与Chord类似，在Pastry中的节点和数据项是一个m位的标识符，这些标识符创建了一个由2^m个顺时针均匀分布在环上的点组成的标识符空间。m通常为128。协议使用SHA-1哈希算法。

在这个协议中，节点标识符和关键字被表示成2b进制的数字串，其中b通常取值为4。

在标识符空间中，关键字存储在节点标识符与其最接近的那个节点上。

Pastry中每个节点拥有一个路由表、一个叶子节点集合及和一个邻居节点集合，它们一起构成了节点的状态表。

其中：

**路由表**（routing table）：每个节点的路由表有m/b 行，每行 2^b列（数据 2^b-1项）。其中第ｎ行表示该行记录的节点的标识符与当前节点的前ｎ位相同， 且第ｎ＋１位与当前节点的不相同。

**叶子节点集**（leaf set）： 容量为L，**用于保存在数值上最接近当前节点标识符的节点**，其中数值小于节点标识符和大于节点标识符的节点各占一半。

**邻居节点集**(neighborhood set)是保存节点的直接邻居 （ 如 ping值最小的2b或2x2b个节点），它不是用来路由消息的， 而是为配置网络服务的。路由表和叶子节点集用来进行路由。

#### **路由表**

给出普通情况下的路由表大纲。在节点N的路由表中，i行j列的单元格[i，j]中给出了一个节点的标识符（如果存在的话），这个节点最左边i位与N的标识符相同，第（i + 1）位的值为j。

第0行给出了一组活动节点列表，这些活动节点的标识符与N没有相同前缀。第1行给出另一组活动节点列表，这些活动节点与节点N最左边的1位数字是相同的。类似地，第31行这些活动节点与节点N的左边31位数字是相同的，只有最后一位不相同。

**当有更多的节点符合插入路由表的某一个位置时**，则根据**接近度**（proximity metric），最接近的节点被选中并将其标识符插入表格内。接近度是一种由使用网络的具体应用决定的度量。它可能基于节点间的跳数、往返时间或其他度量。

| **公共前缀长度** | **0**            | **1** | **2** | **3** | **4** | **5** | **6** | **7** | **8** | **9** | **A** | **B** | **C** | **D** | **E** | **F** |
| ---------------- | :--------------- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| **0**            |                  |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| **1**            |                  |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| **。。。。。。** | **。。。。。。** |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |
| **31**           |                  |       |       |       |       |       |       |       |       |       |       |       |       |       |       |       |

#### **叶子节点集**

路由中的另一个实体是由2^b个标识符组成的集合，它称为叶子节点集（leaf set）。集合中一半的节点标识符在数值上小于当前节点；集合中另一半的节点标识符在数值上大于当前节点。换言之，叶子节点集给出了环上位于当前节点之前的2^(b-1)个节点以及位于之后的2^(b-1)个节点。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Pastry.PNG)

#### **查找**

Pastry中的查找是给定一个关键字，我们需要找到存储着关键字相关信息或关键字自身的节点。下面以伪代码形式给出了查找操作。N是本地节点的标识符，它是接收报文的节点同时也需要找到存储着报文中关键字的节点。

```!
Lookup(key)
{
	If（key is in the range of N’s leaf set）
		forward the message to the closest node in the leaf set
	else
		route（key，Table）
}
route（key，Table）
{
	p=length of shared prefix between key and N
	v=value of the digit at position p of key  //从0 开始的位置
if（Table[p,v] exists）
  forward the message to the node in Table[p,v]
else
  forward the message to the node sharing a prefix as long as the current node,
  but numerically closer to the key. 
}
```

**例2.3.6** 在图中， 我们假设节点N2210接收到一个查询，它寻找负责关键字2008的节点。

  （1）因为当前节点不负责这个关键字，它首先检查自己的叶子节点集。关键字2008不在叶子节点范围内，所以节点需要使用路由表。

  （2）因为关键字与当前节点的公共前缀的长度是1，即p = 1。关键字中第1位数字的值为v = 0，节点在表[1，0]中检查标识符，得到结果2013。

  （3）查询被转发给节点2013，它实际上负责这个关键字。节点将它的信息发送给请求节点。

**例2.3.7** 在图中，我们假设节点N0302接收到一个查询，它寻找负责key0203的节点。当前节点不负责这个关键字，但是这个关键字在它的叶子节点集范围内。这个集合中与key最近的节点是N0202。查询被发送到这个节点，实际上就是负责这个关键字的节点。节点N0202将它的信息发送给请求节点

#### **节点加入**

加入Pastry中的环要比Chord中更简单更快速。一个新的节点X应该知道至少一个节点N0，这可以通过运行一个名为发现附近节点的算法来完成。节点X发送一个加入报文给节点N0。

我们假设N0的标识符与X的标识符没有公共前缀。（如果有公共前缀长度为p，那么可以用N0前p-1行的信息作为X的前p-1行的信息）以下步骤给出了节点X如何构造路由表及叶子节点集：

1．节点N0发送第0行的内容给节点X。因为两个节点没有公共前缀，节点X使用这个信息的适当部分来构造自己的第0行。之后，节点N0将加入报文作为查找报文进行处理（假设X的标识符为关键字标识符），找到N1节点，N1的标识符更接近X 。它向节点N1转发加入报文。

2．节点N1发送第1行的内容给节点X。因为这两个节点有一个相同前缀，节点X使用这个信息的适当部分来构造自己的第1行。之后，节点N1将加入报文作为查找报文进行处理，假设X的标识符为关键字，找到N2节点，它向节点N2转发加入报文，N2的标识符更接近X。

3．这个过程继续，直到X的路由表完成。

4．过程中的最后一个节点，与X有最长的公共前缀，它向节点X发送叶子节点集，这个集合变成了节点X的叶子节点集。

5．然后节点X与它路由表中的节点交换信息和叶子节点集，从而来改善自己的路由信息并允许那些节点更新自身信息。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Pastry-Add.PNG)

加入过程如下：

1) 2212与0302没有公共前缀，所以0302把0行的内容发给2212，作为2212路由表的第0行，因为0302的【0，2】中的内容是2001与2212有共同的前缀2，所以把在2212的路由表中要把第0行的这项内容去掉；

2) 由0302节点发起查找关键字2212的请求，找到最接近的节点2001，于是向2001节点发出加入2212的请求；

3) 2001与2212有一个共同的前缀2，所以把2001的第1行内容发送给2212节点，作为其路由表的第1行的内容，由于2001的【1，2】中的内容是2200，与2212有两项共同的前缀，所以在2212的路由表中的第1行要把这项去掉；

4) 由2001节点发出查找关键字2212的请求，找到最接近的节点2200，于是向2200节点发出加如2212的请求；

5) 2200与2212有共同前缀22，所以把2200的第2行内容发送给2212，作为其路由表的第2行内容，同样2200的【2，2】中的内容2210与2212有3项共同的前缀，所以在2212路由表的【2，2】内容去掉；

6) 有2200节点发出查找关键字2212的请求，找到最接近的节点2210，于是向节点2210发出加入2212的请求；

7) 2210与2212有共同前缀221，所以把2200的第3行内容发送给2212，作为其路由表的第3行内容，同样2200的【3，3】中的内容2213与2212的第3项不同，所以不用修改；至此2212的路由表完成；

8) 最后一个节点2210与2212有最长的共同前缀，节点2210将自己的叶子节点集发送给2212，作为2212的叶子节点集；

9) 节点2210与其路由表中的节点和叶子节点集中的节点交换信息，改善自身的信息，并且让那些节点改善自身的信息；

整个加入过程完成。

#### **离开或失效**

每个Pastry节点都将周期性地发送探测报文，来检测叶子节点集和路由表中的节点存活状况。如果一个本地节点发现叶子节点集中的某个节点对探测报文无响应，它就假设这个节点已经失效或离开。为了替代这个节点，本地节点与叶子节点集中具有最大节点标识符（或最小节点，根据失效节点的大小判断）的活动节点联系，并且利用那个节点的叶子节点集信息修复自己叶子节点集信息。

如果本地节点发现路由表中[i，j]节点对探测报文没有响应，它就发送报文给同一行的活动节点并请求表[i，j]的标识符。这个标识符代替了失效或离开的节点。

#### **算法分析**

Pastry算法具有以下优点：

（1） Pastry算法利用了成熟的最大掩码匹配算法，在实现时可以利用很多现成的软件算法和硬件框架，可以获得很好的效率。

（2） Pastry算法引入了叶子节点和邻居节点集合，当应用层能够及时准确地获得这两个结合的节点时，路由查找速度可以大大提高，并且降低了因路由引起的网络传输开销。

但是在动态变化的P2P网络中，**如何准确地获取叶子节点集合和邻居节点集合的信息有很大的难度。**

### CAN算法

内容寻址网络(CAN Content-Addressable Network)由加州大学伯克利分校于2001年提出。CAN也是DHT的一个变种。CAN的设计基于虚拟的d维笛卡尔空间，这个坐标空间完全是逻辑的，和任何物理坐标系都没有关系。

#### **标识符空间**

在哈希算法上．CAN与Chord、Pastry有所不同。在Chord和Pastry中，采用的一致性哈希算法哈希后得到的键值总是一维的，而在CAN中，哈希后的结果是一个d维的笛卡尔空间，d是一个由系统规模决定的常量。

在CAN中，首先确定一个d维的笛卡尔空间，然后根据当前系统中节点的数量n将这个d维空间等分成n个独立的互不相交的d维子空间区域，把每个子区域分配给一个节点（分配方式可采用随机的方式。也可以将节点的IP地址使用哈希函数计算得到一个d维坐标，再根据坐标的位置分配对应的空间），我们称这个节点负责这个区域。CAN中的节点自组织成一个代表这个虚拟坐标空间的重叠网络（overlay network），每个节点要了解并维护自己的邻居节点的IP地址以及邻居节点存储的引用信息（（K，V）对），用这些邻居信息构成自身的坐标路由表。有了这张表，CAN可以在坐标空间中任意两点间进行路由。

在笛卡尔空间中两个节点互为邻居的定义：在ｄ维笛卡尔坐标空间中，两个节点负责的区域在ｄ-1维的坐标上有重叠，剩余的一维坐标上相互邻接，则称这两个节点为邻居关系。

在CAN算法中，每个节点最多维护2d 个邻居节点的信息，这样CAN 的可扩展性很好，节点数增加时每个节点维护的状态信息不变，坐标空间中两点之间可以有许多条不同的路径，单个节点的失效对CAN 基本上没有太大的影响，遇到失效节点时，CAN 会自动沿着其他的路径进行路由。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-CAN.PNG)

在图中，D节点和E节点是邻居节点，但B节点和C节点不是邻居节点，因为在两维上都邻接，但是没有重叠的；C和E节点也不是邻居节点，虽然他们有一维坐标是重叠的但另一维不邻接。

#### **路由**

查询节点首先计算被查询内容的键值，得到一个d维向量坐标，首先看查询信息是否存储在本地节点，如果是则返回本地节点信息（这与Chord、Pastry是一致的）；如果不是，就在邻居节点表中查找与该向量最为接近的邻居节点，找到后向该节点发送查询请求，这一策略称为贪心策略。收到查询请求的节点如果发现查询的信息存储在本地，则直接回应查询节点；如果发现被查询的信息不在本地，则根据自己的邻居节点表，向接近查询目标的邻居节点转发请求。这样的过程一直持续到找到包含查询信息的节点为止。

**例2.3.9** 如图所示，该CAN是映射在一个2维的笛卡尔空间上，节点1的坐标区间是(0.75～1,  0.5～0.75)。它查找的内容的键值为( 0.45，0.15)，它的邻居节点表的表项分别是( 0.75～1，0.25～0.5)、( 0.75～1，0.75～1)、( 0.5～0.75，0.5～0.75)，经过ＣＡＮ的路由算法，最终找到节点7，坐标区间是( 0.25～0.5，0～0.25)。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-CAN-route.PNG)

如果查询节点或转发节点发现节点表中无法找到可用的下一节点，则采用非结构化P2P网络中常用的扩展环搜索（Expanding Ring Search，使用无状态、受控的泛洪算法在单播的CAN中搜索）以找到合适的（采用贪婪策略）下一节点。

#### **节点的加入和离开**

CAN是一种动态网络，一个新的节点加入CAN时，必须获得自己负责的坐标空间。这个过程是通过现有节点分割自己的区域实现的。CAN中的节点加入分为如下3步：

(1)新节点D首先选择空间的一个点P（P点的坐标可以随机选择或通过D的IP进行哈希运算得到）；然后找到一个已经存在于CAN中的节点A，由节点A发起查询点P的查询请求；

(2)节点A通过CAN的路由算法找到包含点P的空间的负责节点C，然后节点C将自己负责的空间进行分割（一分为二）：

(3)分割后的两个区域中包含点P的区域移交给新节点D，另一部分留给节点C，节点C、D更新自己的邻居节点表，并通知节点C原来的邻居节点更新路由信息（邻居节点表）。

当节点离开CAN时，必须保证它的区域被CAN系统收回，即由离开节点的某个邻居与自己的区域合并或者接管。如果一个邻居节点可以与离开节点的区域合并为一个有效的区域，则把两个区域进行合并，然后更新自己以及邻居节点的信息。如果离开的节点所有的邻居都不能与这个节点合并成一个有效的区域，就由节点中空间最小的节点接管这个区域，在这种情况下，一个节点临时负责两个区域。

在CAN中，一个节点正常情况下定期向邻居节点发送自己更新信息，如果长时间接收不到邻居节点的信息，则认为邻居节点离开，就开始启动移交操作，把自己与离开节点进行合并或由邻居节点中的最小节点接管离开节点的区域。

#### **算法分析**

CAN同Chord、Pastry等采用一维虚地址空间的P2P网络相比，最主要的区别在于路由算法不同，其优点和缺点都是显而易见的。

(1)当节点数量非常大时，CAN的平均查询路径长度要比Chord、Pastry长。

(2)在查询过程中．CAN需要的运算量也要高于Chord、Pastry。

(3)在路由表方面，CAN使用的d为预先设置的常量，与系统的节点数量无关。即使在节点总数变化范围很大的系统中．CAN中节点的邻居节点表结构也能保持稳定，这是P2P的应用中是非常重要的优点。

### Kademlia算法

Kademlia算法(以下简称Kad算法)是在2002年发布的。Kad算法也是一种DHT算法，和其他 DHT 算法比较，如 Chord、CAN、Pastry 等，Kad算法以异或算法(XOR)为距离度量基础，建立了一种全新的DHT 拓扑结构，大大提高了路由查询速度。

Kad算法中，两个标识符（节点或关键字）之间的距离是通过位异或（XOR）来度量的。换言之，如果x和y是两个标识符，我们有x和之间的距离定义为d（x,y）：

d（x,y）=x⊕y

当我们度量两点间的几何距离时，XOR有以下四个特性：

​	(1)d（x,x）=0：点A到自身的距离为0；

​	(2)如果x≠y，则d（x,y）>0：点A到点B之间的距离大于0；

​	(3)对于 任意x，y，d（x,y）=d（y，x）：点A到点B的距离与点B到点A的距离相等；

​	(4) d（x,y）+d(y，z)≥d（x,z）：点A经过B在到点C的距离大于等于点A直接到点B的距离。

#### **标识符空间**

在Kad算法中，首先也要将节点和数据项使用哈希函数计算成m位的标识符，由此创建了含有2^m个点的标识符空间，Kad算法将这些点分布在一个m层的二叉树的叶子节点上。（Kad算法了使用SHA-1哈希算法，其中m = 160。）

同样Kad算法将关键字存储在距离最近的节点中，但是由于采用了位异或（XOR）来度量距离，因此有时尽管一个关键字和某个节点的标识符在数字上看上去很近，但是却常常将关键字存储在另外的节点上，如图所示：

**例2.3.10** 为方便起见，我们假设m = 4。在这个空间中有16个分布在二叉树叶子节点上的标识符。给出了只有8个活动节点以及5个关键字的情况。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Kademlia.PNG)

如图所示，由于3⊕3 = 0，因此关键字k3存储在节点N3上。尽管关键字k7看起来与N6和N8在数字上等距，但是，它却存储在N6上，因为6⊕7 = 1而6⊕8 = 14。另一个有趣的点是关键字k12，它与N11在数字上更接近，但它却存储在N15上，因为11⊕ 12 = 7但是15⊕12 = 3。

#### **路由**

Kad算法为每一个节点维护一个路由表。路由表有m行但只有1列。第i行包含了与该节点有公共长度为i位的最接近该节点的节点。为方便讨论，我们假设每一行存储了该节点的子树中的一个节点的标识符（实际上Kad算法允许每行有多达k个节点，我们后面讨论）。这个想法和Pastry相同，但是公共前缀的长度是基于比特位的个数，而不是基于2b的数字个数。表给出了一个节点的路由表。

| 公共前缀长度 | 标识符                              |
| ------------ | ----------------------------------- |
| 0            | 子树中公共前缀长度为0的最接近节点   |
| 1            | 子树中公共前缀长度为1的最接近节点   |
|              |                                     |
| m-1          | 子树中公共前缀长度为m-1的最接近节点 |

​     表 2.3.3 Kademlia节点的路由表

网络中每个节点将二叉树分成m棵子树这些树并不包含节点自身。子树i包含了那些与相应节点共享最左i位数字（公共前缀）的节点

**例2.3.11** 让我们来找例2.3.10中的所有节点路由表。为简便起见，我们假设每行仅使用一个标识符。因为m = 4，每个节点有四个子树，这些子树对应路由表中的四行。每行的标识符代表在该节点的一个子树中与当前节点距离最近的点。图2.3.12给出所有节点的路由表和三个节点的子树。

我们以节点6举例，使用对应的子树来解释一下如何构造路由表。对于其他节点的解释是类似的。

a．在第0行，我们需要插入一个节点标识符，这个节点在子树中公共前缀长度p = 0且距离最近。在这棵子树中有三个节点（N8、N11以及N15），然而，N15与N6最近，因为N6ÅN8 = 14，N6ÅN11 = 13并且N6Å N15 = 9。N15就被插入到第0行。

b．在第1行，我们需要插入一个节点标识符，这个节点在子树中公共前缀长度p = 1且距离最近。在这棵子树中有三个节点（N0、N1以及N3），然而，N3与N6最近，因为N6ÅN0 = 6，N6Å N1 = 7并且N6ÅN3 = 5。N3就被插入到第1行。

c．在第2行，我们需要插入一个节点标识符，这个节点在子树中公共前缀长度p = 2且距离最近。在这棵子树中只有一个节点（N5），它就被插入到那里。

d．在第3行，我们需要插入一个节点标识符，这个节点在子树中公共前缀长度p = 3且距离最近。在这棵子树中没有节点，因此这行为空。

| 节点N0 |      |      | 节点N1 |      | 节点N3 |      | 节点N5 |      | 节点N6 |      | 节点N8 |      | 节点N11 |      | 节点N15 |      |
| ------ | ---- | ---- | ------ | ---- | ------ | ---- | ------ | ---- | ------ | ---- | ------ | ---- | ------- | ---- | ------- | ---- |
| 0      | N8   |      | 0      | N8   | 0      | N11  | 0      | N15  | 0      | N15  | 0      | N0   | 0       | N3   | 0       | N6   |
| 1      | N5   |      | 1      | N5   | 1      | N6   | 1      | N1   | 1      | N3   | 1      | N15  | 1       | N15  | 1       | N11  |
| 2      | N3   |      | 2      | N3   | 2      | N1   | 2      | N6   | 2      | N5   | 2      | N11  | 2       | N8   | 2       |      |
| 3      | N1   |      | 3      | N0   | 3      |      | 3      |      | 3      |      | 3      |      | 3       |      | 3       |      |

**例2.3.12** 在图中，我们假设节点N0（0000）2接收到一个查找报文，报文要找负责k12（1100）2的节点。这两个标识符的公共前缀长度为0。节点N0发送报文给路由表第0行的节点N8。现在N8（1000）2需要查找与k12（1100）2最近的节点。这两个标识符的公共前缀长度为1。节点N8将这个报文发送给路由表第1行的节点N15，N15负责这个关键字k12。路由过程结束。这个路由是N0→N8→N15。节点N15（1111）2以及k12（1100）2公共前缀长度为2，但是N15的第2行是空的，这意味着N15它自身负责k12。

**例2.3.13** 在图中，我们假设节点N5（0101）2接收到一个查找报文，报文要找负责k7（0111）2的节点。这两个标识符的公共前缀长度为2。节点N5发送报文给路由表第2行的节点N6，这个节点负责k7。路由过程结束。这个路由是N5→N6。

**例2.3.14** 在图中，我们假设节点N11（1011）2接收到一个查找报文，报文要找负责k4（0100）2的节点。这两个标识符的公共前缀长度为0。节点N11发送报文给路由表第0行的节点N3。现在N3（0011）2需要查找与k4（0100）2最近的节点。这两个标识符的公共前缀长度为1。节点N3将这个报文发送给路由表第1行的节点N6。现在节点N6（0110）2需要查找与k4（0100）2最近的节点。这两个标识符的公共前缀长度是2。节点N6发送报文给路由表2行的节点N5，这个节点负责关键字k12。路由过程结束。这个路由是N11→N3→N6→N5。

#### **k-**桶

在之前的讨论中，我们假设路由表中每一行仅仅列出对应子树中的一个节点。为了提高效率，Kad算法要求每一行至少维护k个来自对应子树的节点。k的具体数值依赖于系统，但是实际网络中推荐使用20左右的数值。因此，路由表中每一行称为一个k-桶（k-bucket）。在每一行中包含一个以上节点可以允许客户在节点离开网络或失效时使用替换节点。Kad算法将那些在网络中连接很长时间的节点存储在桶中。已经证明的是，保持连接时间越长的节点越有可能在更长时间内保持连接。

#### **并行查询**

由于在k-桶中有多个节点，Kad算法允许向k-桶顶部a个节点发送a个并行查询。如果一个节点失效或无法回应查询，并行查询将减少延迟。

#### **并发更新**

Kad算法中另一个特性是并发更新。无论何时，当一个节点收到查询或响应，它都立即更新k-桶。如果发向一个节点的多个查询没有收到响应，发送查询的节点将从相应的k-桶中去除这个目的节点。

#### **节点加入**

如Pastry中，一个要加入网络的节点需要知道至少一个节点。加入的节点向网络中的节点发送自身标识符，好像这个标识符是要查找的关键字。它接收到的响应允许新节点创建自己的k-桶。

#### **离开或失效**

当一个节点离开网络或失效时，其他节点使用如上所述的并发过程来更新它们的k-桶。

#### **算法分析**

  Kad算法中基于异或拓扑的路由算法与Pastry的路由算法中非常的相似，其特点是采用采用异或运算计算标识符之间的距离并以此对哈希表进行分层。

   Kademlia的优点在于：

- 对于任意一个有2𝑛个节点的网络，最多只需要n步搜索即可找到目标节点；

- K-bucket的更新机制一定程度上保持了网络的活性和安全性。

- Kad算法使用并行的、异步的查询请求来避免节点失效所带来的超时时延。

### 小结

以上介绍了4类结构化的P2P分布式网络。通过这4类网络的对比可以看出，它们具有很多相似的特点，譬如都采用了虚拟地址的形式标识网络节点和数据对象，在处理节点的加入和退出时都采取了相似的步骤等。但是在路由机制方面，各类网络采用了不同的算法，从而导致了不同的网络特性。基于这些系统，研究人员还设计了具有更好性能的改进路由机制。当然，基于分布式哈希表的路由机制也存在无法解决的问题，主要表现为以下几点：

- 经过哈希算法之后，节点的位置信息被破坏了，来自同一个子网的节点很可能节点ID相距甚远，这造成了虚拟地址和物理地址的不匹配，从而不利于查询性能的优化（比如中国的一个节点可能在逻辑上与一个欧洲的节点很近）。

- 基于哈希表的系统不能利用上层应用本身的信息，许多应用（比如文件系统）的数据本身是按照层次结构组织的，而在使用教列函数后，这些层次信息就丢失了。（内容相近的资源，其引用信息会存储在完全不同的节点上，这样就无法按照习惯性的分类原则查找相关的资源。比如要共享《区块链技术（一）》和《区块链技术（二）》这两个资源，采用DHT技术后，这两个资源的信息会存在两个没有联系的节点上，需要分别进行两次搜索。）

- 另外使用哈希算法也无法很好地与内容语义进行匹配，不能进行模糊查找。因为对内容的关键字进行哈希计算，并用计算的结果来确定引用信息存储的位置，因此搜索时必须对关键字进行精确搜索，如果关键字不同，则搜索结果也会于期望值相差很大，还很有可能搜索不到。

## 非结构化P2P网络的搜索技术

非结构化的P2P网络的搜索技术分为两类：不利用任何文档分布信息的盲搜索和利用网络中文档分布信息的搜索。前者可以抽象为如何从一个随机图中的任意一个节点出发定位目标点，使得整个过程遍历的点的个数最少；后者的特点是网络中的各个节点记录以前接收过的请求和应答，并将这种相关性作为对后续路由的启发。

非结构化的P2P网络路由时需要覆盖较多的节点．花费较大的通信代价和主机计算代价，特别是在对稀疏资源进行定位时。因此，发现的准确性和网络的可扩展性是非结构化的P2P网络面临的两个重要问题。

### Flooding算法（泛洪）

在这种路由技术中，消息像洪水一样在网络中的各个节点间流动，所以被称作Flooding路由。从算法特性上看，它实际上是一个宽度优先搜索(BFS)，算法首先遍历自己的相邻节点，然后再向下遍历。

Flooding路由技术的典型网络代表是Gnutella，它的具体路由方法如下。

在网络中，节点要查找某个文件时，首先向它的相邻节点传递查询信息。如果某个相邻节点拥有这个资源，就向查询节点返回一个QueryHit消息，否则，相邻节点就把消息转发给自己的相邻节点。在整个路由过程中，节点通过消息的TTL（Time To Live）值来判断消息是否过期。

如图所示，节点的查询消息最初设置TTL=4，每传播一次后TTL减1。如果当TTL减到O时还没有搜索到资源，则节点停止传递消息；如果搜索到资源，则按照原路径将目标机器的信息返回给查询节点。在消息传播的过程中可能出现循环，但是由于有TTL控制，因此这个循环不会永运进行下去，当TTL=0的时候自然结束。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Flooding.PNG)

Flooding路由算法的优点缺点都是非常明显的，主要表现在以下几个方面：

1) 路由算法比较简单，易于实现；

2) 可采用多种路由算法，各种算法可分别实施，易于实现。

3) 每次路由都是在进行全网式的遍历，增加了网络的负担，搜索的效率不高；

4) 整个网络的可扩展性差；（节点的增减带来速度的降低）

5. 路由算法容易被攻击。

### Modified-BFS算法

Modified-BFS是Flooding路由算法的一种改进算法，它的改进点主要针对的是控制节点路由消息的扩散范围。

这种路由算法的大部分路由机制都是与Flooding算法相同的，也是采用了全网遍历的盲搜索形式进行消息的路由。唯一的区别在于，在Modified-BFS中，节点在路由消息时不再向它的所有的相邻节点发送消息。而是按照一定的概率随机地选择部分的节点发送消息（概率根据系统的设计确定）。

 Modified-BFS算法的特性同Flooding算法非常相似，区别在于以下两点。

1) 减少了网络中的路由消息，降低了网络的负载，提高了路由的效率：

2) 由于对整个网络的覆盖降低了，所以可能需要花费更长的时间才能定位到目标节点。

### Iterative Deepening算法（迭代增强）

Iterative Deepening也是对Flooding算法的一种改进，与Modified-BFS不同的是，它的改进点主要针对的是控制节点路由消息的扩散程度。

这种路由算法也是对Flooding路由的一种改进，其主要的特点是使用了变化的TTL值控制路由的深度。在策略上，Iterative Deepening定义了两个系数P和W。P代表TTL的变化区间，例如P={a,b,c,d}：W代表每次迭代的时间间隔。具体的路由方法如下。

首先，查询节点采用宽度优先搜索准则向相邻节点发送查询消息，消息的TTL=a。消息传递到TTL=0时停止，并且此时的边界节点临时缓存查询消息：查询节点如果在时间W内收到了匹配的响应，则停止查询，否则，在W时刻向相邻节点发送Resend消息，消息的TTL=a；非边界节点在接收到Resend消息时。只是简单的转发消息，边界节点接收到Resend消息时，将开始缓存的查询消息的TTL设置为b-a，继续向它的相邻节点发送；同理．在下一个W时刻到达时，如果查询节点没有收到匹配的响应，则发送Resend消息，消息的TTL=b，同样边界节点接收到Resend消息时，将开始缓存的查询消息的TTL设置为c-b，继续向它的相邻节点发送；再下一个W时刻发送的Resend消息的TTL=c。

Iterative Deepening的路由如图所示。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Iterative.PNG)

Iterative Deepening路由算法改进了Flooding路由方法，使TTL没有在一开始就被赋予一个较大的值，减少了搜索的半径。这种路由算法的特点主要表现在：

1) 在网络中重复资源丰富时，它可以在不影响搜索质量的前提下减少网络的查询流量；

2) 在最坏情况时，它的搜索延迟将很大，因为TTL的逐步递增导致了开销的增加。

### Random Walk算法（随机游走）

Random Walk也是对Flooding算法的一种改进,同前面两种改进算法相比，这种算法对节点路由消息的控制更加明显，在路由消息的扩散范围和扩散程度两个方面都对算法进行了改进。

这种路由算法的具体的路由方法如下：

查询节点将随机挑选n个相邻节点发送查询请求。中间节点每次随机选择自己的一个相邻节点转发消息，查询请求在路由过程中与请求节点保持联系。查询请求也被称为“walker”。

查询请求在以下3种情况下停止继续路由：

1) 成功找到查询的内容：

2) 当消息的TTL=0时；

3) 定期发送checking消息给查询节点，询问是否终止查询。

在Random Walk路由算法中，两个参数的取值对算法性能有很大的影响，分别是walker的数量n和发送checking消息的步长S：

1) 如果n取值太大，将增大网络的负载，如果n的取值太小，将增加查询的延时，一般n的取值为16～64；

2) 如果S取值太大，将降低checking的作用，增大网络的负载，S取值太小将造成查询节点出现阻塞，试验表明当S=4时，网络达到一个很好的均衡点。

Random Walk算法的最大优势在于查询过程中路由消息的减少。即使是在最坏情况下，一次查询网络中也只会产生n×TTL条路由消息，这与所依赖的网络结构无关。另外，它也从一定意义上实现了本地节点的负载均衡，因为没有哪个节点在消息的转发过程中是热门节点。

Random Walk算法的最大劣势在于表现的不稳定性上。查询的成功率在很大程度上取决于网络的拓扑结构和随机性的选择上，与查询节点和目标节点间的距离的相关性反而很小。这种算法的另一个缺陷在于它对查询对象不能动态地适应。它无法从上一次的查询中获得任何信息，对于热门对象或冷门对象都是同等对待。

### 查询路由（Query Routing）

Query Routing也可以看作是对Flooding算法的一种改进，它改进的地方主要是体现在它对路由的节点进行了控制，不再是随机地向全部节点或者部分节点进行路由，而是有针对性地向关联节点进行路由。

这种路由算法是一种启发式搜索算法。首先每个Peer都给本节点的资源做索引。并且记录相邻节点的资源信息。当查询到达的时候，节点首先查询本节点中的资源情况，然后查询相邻节点是否也存在与该查询匹配的节点，如果存在，则向该节点发送消息，如果不存在，则直接返回查询结果。

对于Query Routing来说，算法的关键在于节点建立的索引。算法将设置一个参数--跳数（hcp count）来确定索引的范围。该参数决定了节点维护索引的相邻节点离本节点最远的跳数。如果跳数设置得太大，那么节点的存储量将非常大，影响节点的性能。

Query Routing的路由如图所示，跳数（hop count）设置为l，每个节点只记录与它相邻的节点的资源信息。当P1发起路由查询时，首先查询本地的索引信息，然后查询相邻节点的资源信息，发现只有P2可能提供被检索的数据，所以P1只向P2构造并发送路由消息，路由消息中还包括P1自己的索引信息。P2接收路由消息后，首先检查自己本地的索引信息。然后再判断自己的相邻节点中P3可能提供被检索的数据，于是P2重新构造路由消息发送给P3，其中包括P1和P2的搜索结果。以此类推，最后P9发现没有相邻节点可能提供被检索的散据，就将最终的结果返回给P1。在Query Routing算法中．如果节点一开始就没有检测到任何相关的节点可能能够提供被检索的数据，那么系统可以考虑直接使用Flooding算法进行路由。

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-p2p-Routing.PNG)

由于Query Routing在路由节点的选择上又很强的针对性，因此路由消息的冗余比Flooding算法减少了很多，在路由的时间和网络的负荷量方面都体现出明显的优势。但是这种对路由的有效关联是建立在每个节点都必须建立资源索引的基础上的，所以每个节点需要存储更多的信息，并且对这些信息进行有效的维护，形成系统的额外成本，如何在搜索的网络成本与节点成本上去的平衡，是该算法今后研究的关键点之一。

### Gnutella2算法

Gnutella2与Flooding算法的有很大的区别，为了减少系统中的路由信息，这种算法采用了两级节点的方法，将系统分成了两级网络。

Gnutella2与Flooding算法的有很大的区别，为了减少系统中的路由信息，这种算法采用了两级节点的方法，将系统分成了两级网络。

这种算法中，节点分为两种类型，一种是超级节点，一种是叶子节点。叶子节点只与其归属的超级节点连接，超级节点在与超级节点间再联通形成一个网络。超级节点间定期更新本地的存储数据表，以过滤不必要的通信。具体的算法如下：

当叶子节点发起查询的时候，首先在它所归属的超级节点的索引中寻找，如果找到匹配的对象，则返回结果，否则，超级节点将这个查询请求转发给它所连接的其它超级节点，直到找到匹配的对象。



Gnutella2所构成的网络中，节点与节点间不再是完全平等的实体，超级节点负责了大部分的路由功能，普通叶子节点的负载变得非常小。

这种路由算法的优势在于，路由过程中，网络产生的流量负荷大大减少，普通叶子节点的负载大大减低，查询延时很小。

但是这种算法的缺陷也是显而易见的，由于存在超级节点，网络的拓扑结构完全依赖于超级节点，当超级节点失效或遭到攻击时，叶子节点将完全瘫痪。因此，对于超级节点的管理维护，在这种路由算法中时至关重要的。

### 小结

通过对上述几种网络的搜索技术的描述可以看出，对于非结构化PZP网络的可扩展路由技术而言，其本质就是通过一种方法尽可能少地覆盖网络中的节点，以达到尽可能快地遍历网络中的目标节点。

由于非结构化的P2P网络中没有整个网络的拓扑信息，因此在这样的网络中定位目标节点的唯一方法就是访问足够多的节点，以保证目标节点在这些节点中（从统计学的角度分析）。尽管如此，在达到覆盖目标节点的目的的过程中，还是必须注意以下几个方面。

1) 消息路由过程中的动态终止是非常重要的。依赖于TTL机制的路由技术是不具备动态终止能力的。在Random Walk中描述的Checking机制是路由消息动态终此的一个很好示例。在使用动态终止机制时，必须注意避免对源节点造成阻塞效应。

2) 消息的重复必须尽可能地减少。在最理想的情况下，每个查询消息只访问节点一次。重复访问对于整个网络来说，是一种资源的浪费。

3) 消息覆盖的粒度应该尽可能地小。在路由过程中，消息每一步的递增路由不应该导致巨大的新增被访问节点。在Flooding算法中，消息的路由每多增加一步，将导致指数级的新增被访问节点；在Modffied-BFS算法中，通过设定概率减少每一步新增的被访问节点数；在Iterative Deepening算法中，通过控制消息路由的步数减少网络中被访问的节点数：在Random Walk算法中，更是将每一步的新增被访问节点数控制为常数级。因为在非结构化P2P网络中，定位目标节点所需要的被访问节点数应该是一致的。所以多余的被访问的节点只是增加了网络的负担。

在保证以上各个方面的问题能很好地解决的基础上，路由算法应该尽可能地减少定位节点所需要的时间。

## 局域网穿透技术

### NAT穿透

NAT（Network Address Translation，网络地址转换）是一种网络地址翻译技术，主要是将内部的私有IP地址（private IP）转换成可以在公网使用的公网IP（public IP）。

NAT可以同时让多个计算机同时联网，并隐藏其内网IP，因此也增加了内网的网络安全性；此外，NAT对来自外部的数据查看其NAT映射记录，对没有相应记录的数据包进行拒绝，提高了网络安全性。

但是NAT与此同时也带来一些弊端：首先是，NAT设备会对数据包进行编辑修改，这样就降低了发送数据的效率；此外，各种协议的应用各有不同，有的协议是无法通过NAT的，这就需要通过穿透技术来解决。

下面首先介绍下NAT实现的主要方式，以及NAT都有哪些类型。

#### NAT实现方式

NAT有实现方式：静态NAT(Static NAT)、动态地址NAT(Pooled NAT)、网络地址端口转换NAPT（Port－Level NAT）。
 　1) 静态NAT：也就是静态地址转换。是指一个公网IP对应一个私有IP，是一对一的转换，同时注意，这里只进行了IP转换，而没有进行端口的转换。

2) 动态NAT：动态NAT只是转换IP地址，它为每一个内部的IP地址分配一个临时的外部IP地址，主要应用于拨号，对于频繁的远程联接也可以采用动态NAT。当远程用户联接上之后，动态地址NAT就会分配给他一个IP地址，用户断开时，这个IP地址就会被释放而留待以后使用。

3) NAPT：端口多路复用技术。

   与静态NAT的差别是，NAPT不但要转换IP地址，还要进行传输层的端口转换。具体的表现形式就是，对外只有一个公网IP，通过端口来区别不同私有IP主机的数据。再举个例子。 

现实环境中NAPT的应用显然是更广泛的。因此下面主要介绍NAPT的主要类型有哪些。

####  NAPT的主要类型

​	对于NAPT我们主要分为两大类：锥型NAT和对称型NAT。其中锥型NAT又分三种：完全锥型，受限锥型和端口受限锥型。锥型NAT是多个请求（内部发向外部）对应一个端口，只要源IP端口不变，无论发往的目的IP是否相同，在NAT上都映射为同一个端口，形象的看起来就像锥子一样。对称型NAT是一个请求对应一个端口。下面分别介绍这四种类型及其差异。

##### 完全锥型NAT（Full Cone NAT）

特点：IP和端口都不受限。

- 一旦一个内网地址 (iAddr : iPort) 被映射到一个外部地址 (eAddr : ePort), 来自 iAddr : iPort 的任何数据包将通过 eAddr : ePort 发送.

- 任何外部主机能够通过eAddr : ePort这个地址发送数据包到iAddr : iPort.

##### 受限锥型NAT（Restricted Cone NAT）

特点：IP受限，端口不受限。

- 一旦一个内网地址 (iAddr : iPort) 被映射到一个外部地址 (eAddr : ePort), 来自 iAddr : iPort 的任何数据包将通过 eAddr : ePort 发送.

- 只有接收到主机(iAddr : iPort)通过eAddr : ePort发送的数据包的外部主机通过该主机的任何端口发送到                               eAddr : ePort的数据包才能够被正确的转发到iAddr : iPort.也就是说与主机有关与端口无关.

##### 端口受限型NAT（Port Restricted Cone NAT）

特点：IP和端口都受限。

类似于受限锥形NAT, 但是端口号有限制.

一旦一个内网地址 (iAddr : iPort) 被映射到一个外部地址 (eAddr : ePort), 来自 iAddr : iPort 的任何数据包将通过 eAddr : ePort 发送.

只有接收到主机(iAddr : iPort)通过eAddr : ePort发送的数据包的外部主机通过该主机的相同端口发送到eAddr : ePort的数据包才能够被正确的转发到iAddr : iPort.

##### 对称型NAT（Symmetric NAT）

特点：对每个外部主机或端口的会话都会映射为不同的端口。

来自相同内部ip和port发送到相同目的地ip和port的请求被映射到唯一的外部ip和port地址；如果相同的内部主机采用相同的ip和port地址发送到不同的目的地，那么重新分配映射地址。

只有先前收到内部主机发送的包的外部主机才能够发送返回包到内部主机。

#### UDP协议的NAT穿透技术

首先看看如何使用UDP穿透NAT。

我们假设在两个不同的局域网后面分别有2台客户机A和 B，AB所在的局域网都分别通过一个路由器接入互联网。互联网上有一台服务器S。 

现在AB是无法直接和对方发送信息的，AB都不知道对方在互联网上真正的IP和端口， AB所在的局域网的路由器只允许内部向外主动发送的信息通过。对于B直接发送给A的路由器的消息，路由会认为其“不被信任”而直接丢弃。 要实现 AB直接的通讯，就必须进行以下3步：A首先连接互联网上的服务器S并发送一条消息（对于UDP这种无连接的协议其实直接初始会话发送消息即可），这样S就获取了A在互联网上的实际地址（发送消息的IP和端口号）。接着 B也进行同样的步骤，S就知道了AB在互联网上的地址（这就是“打洞”）。接着S分别告诉A和B对方客户端在互联网上的实际地址，也即S告诉A客户B的会话地址，S告诉B客户A的会话地址。这样，在AB都知道了对方的实际地址之后，就可以直接通过实际地址发送消息了（因为先前双方都向外发送过消息，路由上已经有允许数据进出的消息通道）。

1) STUN协议

   STUN（Session Traversal Utilities for NAT， NAT会话穿透实用协议）协议为终端提供一种方式能够获知自己经过NAT映射后的地址，从而替代位于应用层中的私网地址，达到NAT穿透的目的。STUN协议是典型的Client-Server协议，各种具体应用通过嵌入STUN客户端与STUN Server端通讯来完成交互。

   在典型的运用STUN进行NAT穿透的场景中，STUN客户端首先向位于公网上的STUN服务器发送Binding Request消息，STUN服务器接收到请求消息后识别出经过NAT转换后的公网地址60.1.1.1:12345，将其附加在Binding Response消息中返回给客户端。客户端得到这个地址后用它替换私网地址与终端B完成协商。使用STUN进行NAT穿透对应用的要求是必须使用同样的端口与STUN服务器交互和进行应用层通讯，比如当希望使用端口37000进行NAT穿透时，必须同样使用37000端口与STUN服务器通讯，否则从STUN 服务器获得的NAT映射后的地址一般与实际地址时不一样的。另一个要求是STUN客户端与服务器端的通讯和应用使用获得的NAT映射地址进行应用层通讯在时间上必须有连贯性，这源于NAT设备建立的绑定有生存时间，当原绑定消亡后，NAT设备为同一个私网地址建立的新绑定往往不同，因此转换后的公网地址是不同的。

2) TURN协议

   TURN （Traversal Using Relays around NAT:Relay Extensions to Session Traversal Utilities for NAT，使用中继穿透NAT:STUN的扩展协议）解决NAT穿透的思路与STUN类似，都是通过修改应用层中的私网地址达到NAT穿透。 与STUN不同的是，TURN是通过两方通讯的“中间人”的方式实现穿透，在这种方式下， 要进行通讯的两方分别与位于公网上的TURN服务器建立各自的连接进行通讯，由服务器负责在两方之间进行数据转发。要达到这个目的，实现TURN客户端的终端必须在通讯开始前 与TURN服务器进行交互，得到服务器为其临时分配的位于TURN服务器上的公网地址，客户端使用它替换位于应用层中的私网地址.

#### TCP协议的NAT穿透技术

因为UDP是无连接的协议，它允许socket进行“多对一”的通讯（即几个具有不同IP和端口号的socket向一个接收socket发送消息）。但是使用TCP就出现了问题：在一般情况下，TCP socket不允许在已经建立连接的端口上再进行监听和使用该本地端口。换句话说，当AB连接上服务器S后，S将AB的实际端口告诉对方，下一步本该是AB利用对方的实际端口进行直连，但这时你会发现对方的实际端口已经被占用了（就是各自连接到服务器S的会话占用了端口），无法同时listen和 connect。

于是问题的关键变成了如何复用一个TCP连接的本地终端，这其实不是协议的问题，而是一个API的问题。幸运的是，所有主流操作系统都支持一个特定的TCP套接字选项——SO_REUSEADDR。这个选项允许将多个socket绑定到同一个本地端口。我们建立socket的时候只要加上这么一行：

```
setsockopt(socket, SOL_SOCKET, SO_REUSEADDR, &flag, len) ;  //C++
```



现在假设客户A想和客户B建立TCP连接。 

首先还是 AB分别和服务器S分别建立连接，S记录AB的互联网实际端口。然后S分别向AB发送对方的实际端口。接着，从A和B向S连接时使用的端口，AB都异步调用connect函数连接对方的实际端口（就是S告诉的端口），同时，AB双方都在同一个本地端口监听到来的连接（也可以先监听，再connect更好）。由于双方都向对方发送了connect请求（假设各自的SYN封包已经穿过了自己的NAT），因此在对方connect请求到达本地的监听端口时，路由器会认为这个请求是刚刚那个connect会话的一部分，是已经被许可的，本地监听端口就会用SYN-ACK响应，同意连接。这样，TCP穿透NAT的点对点连接就成功了。

