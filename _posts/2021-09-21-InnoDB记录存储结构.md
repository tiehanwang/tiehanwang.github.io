---
layout: 	post
title: 		InnoDB记录存储结构
subtitle:	页及行格式
date:		2021-09-21
author: 	W
header-img: img/post-bg-mysql.png
catalog: true
tags: 
    - MySQL

---

# InnoDB记录存储结构

## InnoDB页简介

`InnoDB` 将数据划分若干页，以页作为磁盘和内存之间交互的基本单位，`InooDB`中页的大小一般为16KB

## InnoDB行格式

我们平时是以记录位单位来向表中插入数据的，这些记录在次方上的存放方式也被称为`行格式`或者`记录格式`。

`InnoDB` 存在四种不同类型的`行格式`

- `Compact`
- `Redundant`
- `Dynamic`
- `Compressed`

我们可以在创建或者修改表的语句中指定`行格式`:

```mysql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

### Compact行格式

如图

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-mysql-compact.PNG)

一条完整的记录分为记录的额外信息及真实数据两部分

#### 记录的额外信息

这部分信息是<span style="color:red">服务器为了描述这条记录而不得不额外添加的一些信息</span>，分为三类，分别是`变长字段长度列表`、`NULL值列表`和`记录头信息`。

##### 变长字段长度列表

`MySQL`支持一些变长的数据类型，比如`VARCHAR(M)`、`VARBINARY(M)`、各种`TEXT`类型，各种`BLOB`类型，我们也可以把拥有这些数据类型的列称为`变长字段`，变长字段中存储多少字节的数据是不固定的，所以我们在存储真实数据的时候需要顺便把这些数据占用的字节数也存起来，这样才不至于把`MySQL`服务器搞懵，所以这些变长字段占用的存储空间分为两部分：

1. **真正的数据内容**
2. **占用的字节数**

在`Compact`行格式中，<span style="color:red">把所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，**各变长字段数据占用的字节数按照列的顺序逆序存放**</span>，我们再次强调一遍，是<span style="color:red">**逆序**</span>存放！

例如

| 列名 | 存储内容 | 内容长度（十进制表示） | 内容长度（十六进制表示） |
| :--: | :------: | :--------------------: | :----------------------: |
| `c1` | `'aaaa'` |          `4`           |          `0x04`          |
| `c2` | `'bbb'`  |          `3`           |          `0x03`          |
| `c4` |  `'d'`   |          `1`           |          `0x01`          |



如果变长字符串较短一个字节就可以表示，但是如果变长列的内容占用的字节数比较多就需要两个字节来表示。至于具体要用一个还是两个字节来表示真实数据的占用字节数`InnoDB`有他的一套规则，首先我们先声明一下 `W`、`M`、 `L`的意思：

1. 假设某个字符集中表示一个字符最多需要使用的字节数为`W`，也就是使用`SHOW CHARSET`语句的结果中的`Maxlen`列，比方说`utf8`字符集中的`W`就是`3`，`gbk`字符集中的`W`就是`2`，`ascii`字符集中的`W`就是`1`。
2. 对于变长类型`VARCHAR(M)`来说，这种类型表示能存储最多`M`个字符（注意是字符不是字节），所以这个类型能表示的字符串最多占用的字节数就是`M×W`。
3. 假设它实际存储的字符串占用的字节数是`L`。 

所以确定使用一个字节还是两个字节表示真正字符串占用的字节规则如下：

- 如果`M×W <= 255`，那么使用1个字节来表示真正字符串占用的字节数。

  ```!
  也就是说InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数不大于255时，可以认为只使用1个字节来表示真正字符串占用的字节数。
  ```

- 如果`M×W > 255`，则分为两种情况：

  - 如果`L <= 127`，则用1个字节来表示真正字符串占用的字节数。

  - 如果`L > 127`，则用2个字节来表示真正字符串占用的字节数。

  ```!
  InnoDB在读记录的变长字段长度列表时先查看表结构，如果某个变长字段允许存储的最大字节数大于255时，该怎么区分它正在读的某个字节是一个单独的字段长度还是半个字段长度呢？设计InnoDB的大叔使用该字节的第一个二进制位作为标志位：如果该字节的第一个位为0，那该字节就是一个单独的字段长度（使用一个字节表示不大于127的二进制的第一个位都为0），如果该字节的第一个位为1，那该字节就是半个字段长度。
  
  对于一些占用字节数非常多的字段，比方说某个字段长度大于了16KB，那么如果该记录在单个页面中无法存储时，InnoDB会把一部分数据存放到所谓的溢出页中，在变长字段长度列表处只存储留在本页面中的长度，所以使用两个字节也可以存放下来。
  ```

总结一下就是说：如果该可变字段允许存储的最大字节数（`M×W`）超过255字节并且真实存储的字节数（`L`）超过127字节，则使用2个字节，否则使用1个字节。

另外需要注意的一点是，<span style="color:red">变长字段长度列表中只存储值为 ***非NULL*** 的列内容占用的长度，值为 ***NULL*** 的列的长度是不储存的 </span>。

并不是所有记录都有这个 变长字段长度列表 部分，比方说表中所有的列都不是变长的数据类型的话，这一部分就不需要有。

##### NULL值列表

我们知道表中的某些列可能存储`NULL`值，如果把这些`NULL`值都放到`记录的真实数据`中存储会很占地方，所以`Compact`行格式把这些值为`NULL`的列统一管理起来，存储到`NULL`值列表中，它的处理过程是这样的：

1. 首先统计表中允许存储`NULL`的列有哪些。

   我们前边说过，主键列、被`NOT NULL`修饰的列都是不可以存储`NULL`值的，所以在统计的时候不会把这些列算进去。

2. <span style="color:red">如果表中没有允许存储 ***NULL*** 的列，则 *NULL值列表* 也不存在了</span>，否则将每个允许存储`NULL`的列对应一个二进制位，二进制位按照列的顺序<span style="color:red">**逆序**</span>排列，二进制位表示的意义如下：

   - 二进制位的值为`1`时，代表该列的值为`NULL`。
   - 二进制位的值为`0`时，代表该列的值不为`NULL`。

   也就是说和变长字段长度列表逆序是一致的。

3. `MySQL`规定`NULL值列表`必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在字节的高位补`0`。

##### 记录头信息

除了`变长字段长度列表`、`NULL值列表`之外，还有一个用于描述记录的`记录头信息`，它是由固定的`5`个字节组成。`5`个字节也就是`40`个二进制位，不同的位代表不同的意思，如图：

<img src="https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-mysql-header.PNG" style="zoom:200%;" />

这些二进制位代表的详细信息如下表：

|      名称      | 大小（单位：bit） |                             描述                             |
| :------------: | :---------------: | :----------------------------------------------------------: |
|   `预留位1`    |        `1`        |                           没有使用                           |
|   `预留位2`    |        `1`        |                           没有使用                           |
| `delete_mask`  |        `1`        |                     标记该记录是否被删除                     |
| `min_rec_mask` |        `1`        |        B+树的每层非叶子节点中的最小记录都会添加该标记        |
|   `n_owned`    |        `4`        |                   表示当前记录拥有的记录数                   |
|   `heap_no`    |       `13`        |                表示当前记录在记录堆的位置信息                |
| `record_type`  |        `3`        | 表示当前记录的类型，`0`表示普通记录，`1`表示B+树非叶子节点记录，`2`表示最小记录，`3`表示最大记录 |
| `next_record`  |       `16`        |                   表示下一条记录的相对位置                   |

#### 记录的真实数据

`记录的真实数据`除了我们自己定义的列的数据以外，`MySQL`会为每个记录默认的添加一些列（也称为`隐藏列`），具体的列如下：

|            列名             | 是否必须 | 占用空间 |          描述          |
| :-------------------------: | :------: | :------: | :--------------------: |
|     DB_ROW_ID(`row_id`)     |    否    | `6`字节  | 行ID，唯一标识一条记录 |
| DB_TRX_ID(`transaction_id`) |    是    | `6`字节  |         事务ID         |
| DB_ROLL_PTR(`roll_pointer`) |    是    | `7`字节  |        回滚指针        |

这里需要提一下`InnoDB`表对主键的生成策略：优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个`Unique`键作为主键，如果表中连`Unique`键都没有定义的话，则`InnoDB`会为表默认添加一个名为`row_id`的隐藏列作为主键。所以我们从上表中可以看出：<span style="color:red">InnoDB存储引擎会为每条记录都添加 ***transaction_id*** 和 ***roll_pointer*** 这两个列，但是 ***row_id*** 是可选的（在没有自定义主键以及Unique键的情况下才会添加该列）</span>。这些隐藏列的值不用我们操心，`InnoDB`存储引擎会自己帮我们生成的。

#### CHAR(M)列的存储格式

如果采用如`ascii`等定长字符集 则`CHAR(M)`列不会存到`变长字段长度列表`中，但如果采用的是如`gbk` （1~2字节）或 `utf8`（1~3字节）字符集 则会存储到`变长字段长度列表`

这就意味着：<span style="color:red">对于 ***CHAR(M)*** 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表</span>。

另外有一点还需要注意，变长字符集的`CHAR(M)`类型的列要求至少占用`M`个字节，而`VARCHAR(M)`却没有这个要求。比方说对于使用`utf8`字符集的`CHAR(10)`的列来说，该列存储的数据字节长度的范围是10～30个字节。即使我们向该列中存储一个空字符串也会占用`10`个字节，这是怕将来更新该列的值的字节长度大于原有值的字节长度而小于10个字节时，可以在该记录处直接更新，而不是在存储空间中重新分配一个新的记录空间，导致原有的记录空间称为所谓的碎片。

### Redundant行格式

`Redundant`行格式是`MySQL5.0`之前用的一种格式

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-mysql-Red.PNG)

- 字段长度偏移列表

  注意`Compact`行格式的开头是`变长字段长度列表`，而`Redundant`行格式的开头是`字段长度偏移列表`，与`变长字段长度列表`有两处不同：

  - 没有了<span style="color:red">变长</span>两个字，意味着`Redundant`行格式会把该条记录中<span style="color:red">所有列</span>（包括`隐藏列`）的长度信息都按照<span style="color:red">逆序</span>存储到`字段长度偏移列表`。
  - 多了个<span style="color:red">偏移</span>两个字，这意味着计算列值长度的方式不像`Compact`行格式那么直观，它是采用两个相邻数值的<span style="color:red">差值</span>来计算各个列值的长度。

比如第一条记录的`字段长度偏移列表`就是：

```
25 24 1A 17 13 0C 06
```

因为它是逆序排放的，所以按照列的顺序排列就是：

```
06 0C 13 17 1A 24 25
```

按照两个相邻数值的<span style="color:red">差值</span>来计算各个列值的长度。

>第一列(`row_id`)的长度就是 0x06个字节，也就是6个字节。
>
>第二列(`transaction_id`)的长度就是 (0x0C - 0x06)个字节，也就是6个字节。
>
>第三列(`roll_pointer`)的长度就是 (0x13 - 0x0C)个字节，也就是7个字节。
>
>第四列(`c1`)的长度就是 (0x17 - 0x13)个字节，也就是4个字节。
>
>第五列(`c2`)的长度就是 (0x1A - 0x17)个字节，也就是3个字节。
>
>第六列(`c3`)的长度就是 (0x24 - 0x1A)个字节，也就是10个字节。
>
>第七列(`c4`)的长度就是 (0x25 - 0x24)个字节，也就是1个字节。

- 记录头信息

  `Redundant`行格式的记录头信息占用`6`字节，`48`个二进制位，这些二进制位代表的意思如下：

  - |       名称        | 大小（单位：bit） |                           描述                           |
    | :---------------: | :---------------: | :------------------------------------------------------: |
    |     `预留位1`     |        `1`        |                         没有使用                         |
    |     `预留位2`     |        `1`        |                         没有使用                         |
    |   `delete_mask`   |        `1`        |                   标记该记录是否被删除                   |
    |  `min_rec_mask`   |        `1`        |      B+树的每层非叶子节点中的最小记录都会添加该标记      |
    |     `n_owned`     |        `4`        |                 表示当前记录拥有的记录数                 |
    |     `heap_no`     |       `13`        |              表示当前记录在页面堆的位置信息              |
    |     `n_field`     |       `10`        |                    表示记录中列的数量                    |
    | `1byte_offs_flag` |        `1`        | 标记字段长度偏移列表中的偏移量是使用1字节还是2字节表示的 |
    |   `next_record`   |       `16`        |                 表示下一条记录的相对位置                 |

    第一条记录中的头信息是：

    ```
    00 00 10 0F 00 BC
    ```

    根据这六个字节可以计算出各个属性的值，如下：

    ```
    预留位1：0x00
    预留位2：0x00
    delete_mask: 0x00
    min_rec_mask: 0x00
    n_owned: 0x00
    heap_no: 0x02
    n_field: 0x07
    1byte_offs_flag: 0x01
    next_record:0xBC
    ```

    与`Compact`行格式的记录头信息对比来看，有两处不同：

    - `Redundant`行格式多了`n_field`和`1byte_offs_flag`这两个属性。

    - `Redundant`行格式没有`record_type`这个属性。

  - `Redundant`行格式中`NULL`值的处理

    因为`Redundant`行格式并没有`NULL值列表`，所以需要别的方式来存储字段的`NULL`值，具体策略如下：

    - 如果该存储`NULL`值的字段是变长数据类型的，则在字段长度偏移列表中记录即可，并不占用记录的真实数据部分。
    - 如果该存储`NULL`值的字段是`CHAR(M)`数据类型的，则将占用记录的真实数据部分，并把该字段对应的数据使用`0x00`字节填充。

#### CHAR(M)列的存储格式

我们知道`Compact`行格式在`CHAR(M)`类型的列中存储数据的时候还挺麻烦，分变长字符集和定长字符集的情况，而在`Redundant`行格式中十分干脆，不管该列使用的字符集是啥，只要是使用`CHAR(M)`类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和`M`的乘积。比方说使用`utf8`字符集的`CHAM(10)`类型的列占用的真实数据空间始终为`30`个字节，使用`gbk`字符集的`CHAM(10)`类型的列占用的真实数据空间始终为`20`个字节。由此可以看出来，使用`Redundant`行格式的`CHAR(M)`类型的列是不会产生碎片的。

### 行溢出数据

#### VARCHAR(M)最多能存储的数据

我们知道对于`VARCHAR(M)`类型的列最多可以占用`65535`个字节。其中的`M`代表该类型最多存储的字符数量，如果我们使用`ascii`字符集的话，一个字符就代表一个字节，我们看看`VARCHAR(65535)`是否可用：

```
mysql> CREATE TABLE varchar_size_demo(
    ->     c VARCHAR(65535)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
ERROR 1118 (42000): Row size too large. The maximum row size for the used table type, not counting BLOBs, is 65535. This includes storage overhead, check the manual. You have to change some columns to TEXT or BLOBs
mysql>
```

从报错信息里可以看出，`MySQL`对一条记录占用的最大存储空间是有限制的，除了`BLOB`或者`TEXT`类型的列之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过`65535`个字节。所以`MySQL`服务器建议我们把存储类型改为`TEXT`或者`BLOB`的类型。这个`65535`个字节除了列本身的数据之外，还包括一些其他的数据（`storage overhead`），比如说我们为了存储一个`VARCHAR(M)`类型的列，其实需要占用3部分存储空间：

- 真实数据
- 真实数据占用字节的长度
- `NULL`值标识，如果该列有`NOT NULL`属性则可以没有这部分存储空间

如果该`VARCHAR`类型的列没有`NOT NULL`属性，那最多只能存储`65532`个字节的数据，因为真实数据的长度可能占用2个字节，`NULL`值标识需要占用1个字节：

```
mysql> CREATE TABLE varchar_size_demo(
    ->      c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果`VARCHAR`类型的列有`NOT NULL`属性，那最多只能存储`65533`个字节的数据，因为真实数据的长度可能占用2个字节，不需要`NULL`值标识：

```
mysql> DROP TABLE varchar_size_demo;
Query OK, 0 rows affected (0.01 sec)

mysql> CREATE TABLE varchar_size_demo(
    ->      c VARCHAR(65533) NOT NULL
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.02 sec)
```

如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那会怎么样呢？来看一下：

```
mysql> DROP TABLE varchar_size_demo;
Query OK, 0 rows affected (0.00 sec)

mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=gbk ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 32767); use BLOB or TEXT instead

mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=utf8 ROW_FORMAT=Compact;
ERROR 1074 (42000): Column length too big for column 'c' (max = 21845); use BLOB or TEXT instead
```

从执行结果中可以看出，如果`VARCHAR(M)`类型的列使用的不是`ascii`字符集，那`M`的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为`NULL`的情况下，`gbk`字符集表示一个字符最多需要`2`个字符，那在该字符集下，`M`的最大取值就是`32766`（也就是：65532/2），也就是说最多能存储`32766`个字符；`utf8`字符集表示一个字符最多需要`3`个字符，那在该字符集下，`M`的最大取值就是`21844`，就是说最多能存储`21844`（也就是：65532/3）个字符。

#### 记录中的数据太多产生的溢出

我们以`ascii`字符集下的`varchar_size_demo`表为例，插入一条记录：

```
mysql> CREATE TABLE varchar_size_demo(
    ->       c VARCHAR(65532)
    -> ) CHARSET=ascii ROW_FORMAT=Compact;
Query OK, 0 rows affected (0.01 sec)

mysql> INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));
Query OK, 1 row affected (0.00 sec)
```

其中的`REPEAT('a', 65532)`是一个函数调用，它表示生成一个把字符`'a'`重复`65532`次的字符串。前边说过，`MySQL`中磁盘和内存交互的基本单位是`页`，也就是说`MySQL`是以`页`为基本单位来管理存储空间的，我们的记录都会被分配到某个`页`中存储。而一个页的大小一般是`16KB`，也就是`16384`字节，而一个`VARCHAR(M)`类型的列就最多可以存储`65532`个字节，这样就可能造成一个页存放不了一条记录的尴尬情况。

在`Compact`和`Reduntant`行格式中，对于占用存储空间非常大的列，在`记录的真实数据`处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，**然后`记录的真实数据`处用20个字节存储指向这些页的地址**（当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-mysql-overpage.PNG)

从图中可以看出来，对于`Compact`和`Reduntant`行格式来说，如果某一列中的数据非常多的话，在本记录的真实数据处只会存储该列的前`768`个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中，这个过程也叫做`行溢出`，存储超出`768`字节的那些页面也被称为`溢出页`。画一个简图就是这样：

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-mysql-overpage-link.PNG)

最后需要注意的是，<span style="color:red">不只是 ***VARCHAR(M)*** 类型的列，其他的 ***TEXT***、***BLOB*** 类型的列在存储数据非常多的时候也会发生`行溢出`</span>。

#### 行溢出的临界点

那发生`行溢出`的临界点是什么呢？也就是说在列存储多少字节的数据时就会发生`行溢出`？

`MySQL`中规定<span style="color:red">一个页中至少存放两行记录</span>，至于为什么这么规定我们之后再说，现在看一下这个规定造成的影响。以上边的`varchar_size_demo`表为例，它只有一个列`c`，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会`行溢出`的现象呢？这得分析一下页中的空间都是如何利用的。

- 每个页除了存放我们的记录以外，也需要存储一些额外的信息，乱七八糟的额外信息加起来需要`136`个字节的空间（现在只要知道这个数字就好了），其他的空间都可以被用来存储记录。

- 每个记录需要的额外信息是`27`字节。

  这27个字节包括下边这些部分：

  - 2个字节用于存储真实数据的长度
  - 1个字节用于存储列是否是NULL值
  - 5个字节大小的头信息
  - 6个字节的`row_id`列
  - 6个字节的`transaction_id`列
  - 7个字节的`roll_pointer`列

假设一个列中存储的数据字节数为n，那么发生`行溢出`现象时需要满足这个式子：

```
136 + 2×(27 + n) > 16384
```

求解这个式子得出的解是：`n > 8098`。也就是说如果一个列中存储的数据不大于`8098`个字节，那就不会发生`行溢出`，否则就会发生`行溢出`。不过这个`8098`个字节的结论只是针对只有一个列的`varchar_size_demo`表来说的，如果表中有多个列，那上边的式子和结论都需要改一改了，所以重点就是：<span style="color:red">你不用关注这个临界点是什么，只要知道如果我们想一个行中存储了很大的数据时，可能发生`行溢出`的现象</span>。

### Dynamic和Compressed行格式

`MySQL`版本是`5.7`，它的默认行格式就是`Dynamic`，这俩行格式和`Compact`行格式挺像，只不过在处理`行溢出`数据时有点儿分歧，它们不会在记录的真实数据处存储字段真实数据的前`768`个字节，而是把所有的字节都存储到其他页面中，只在记录的真实数据处存储其他页面的地址，就像这样：

![](https://raw.githubusercontent.com/tiehanwang/tiehanwang.github.io/master/img/doc-mysql-dyn.PNG)

`Compressed`行格式和`Dynamic`不同的一点是，`Compressed`行格式会采用压缩算法对页面进行压缩，以节省空间。

#### CHAR(M)中的M值过大的情况

`CHAR(M)`类型的列可以存储的最大字节长度等于该列使用的字符集表示一个字符需要的最大字节数和`M`的乘积。如果某个列使用的是`CHAR(M)`类型，并且它可以存储的最大字节长度超过`768`字节，那么不论我们使用的是上述4种的哪种行格式，`InnoDB`都会把该列当成变长字段看待。比方说采用`utf8mb4`的`CHAR(255)`类型的列将会被当作变长字段看待，因为`4×255 > 768`。

